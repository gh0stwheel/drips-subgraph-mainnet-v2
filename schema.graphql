type User @entity {
  id: ID! # the userId
  assetConfigs: [UserAssetConfig!]! @derivedFrom(field: "user")
  lastUpdatedBlockTimestamp: BigInt!
}

type UserAssetConfig @entity {
  id: ID! # the userId + "-" + assetId
  user: User!
  assetId: BigInt!
  dripsEntryIds: [String!]!
  dripsEntries: [DripsEntry!]! @derivedFrom(field: "senderAssetConfig")
  balance: BigInt! # the user's balance for the asset at last top-up
  assetConfigHash: Bytes!
  lastUpdatedBlockTimestamp: BigInt!
}

type DripsSetEvent @entity {
  id: ID! # event.transaction.hash.toHex() + "-" + event.logIndex.toString()
  userId: BigInt! # the userId of the sender
  assetId: BigInt!
  receiversHash: Bytes! # the hash of the receivers list
  balance: BigInt!
  blockTimestamp: BigInt!
}

type HashToDripsSetDetail @entity {
  id: ID! # receiversHash
  userId: BigInt! # the sender's userId
  assetId: BigInt!
  currentDripSetEvent: DripsSetEvent!
}

type DripsEntry @entity {
  id: ID! # sender's userId + "-" + receiver's userId + "-" + assetId
  sender: User!
  senderAssetConfig: UserAssetConfig!
  receiverUserId: BigInt! # the receiver's userId
  config: BigInt!
}

type DripsReceiverSeenEvent @entity {
  id: ID! # event.transaction.hash.toHex() + "-" + event.logIndex.toString()
  receiversHash: Bytes!
  userId: BigInt! # the receiver's userId
  config: BigInt!
  blockTimestamp: BigInt!
}

type Give @entity {
  id: ID! # the transaction hash
  sender: Bytes!
  isAccountGive: Boolean! # true if this is a sub-account
  account: BigInt! # the sub-account (if isAccountDrip == true)
  receiver: Bytes!
  amount: BigInt!
  blockTimestampGiven: BigInt!
}

type IdentityMetaData @entity {
  id: ID! # the address
  key: Bytes!
  multiHash: Bytes!
}
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class User extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save User entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save User entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("User", id.toString(), this);
    }
  }

  static load(id: string): User | null {
    return changetype<User | null>(store.get("User", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get assetConfigs(): Array<string> {
    let value = this.get("assetConfigs");
    return value!.toStringArray();
  }

  set assetConfigs(value: Array<string>) {
    this.set("assetConfigs", Value.fromStringArray(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}

export class UserAssetConfig extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("user", Value.fromString(""));
    this.set("assetId", Value.fromBigInt(BigInt.zero()));
    this.set("dripsEntryIds", Value.fromStringArray(new Array(0)));
    this.set("balance", Value.fromBigInt(BigInt.zero()));
    this.set("assetConfigHash", Value.fromBytes(Bytes.empty()));
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserAssetConfig entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save UserAssetConfig entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("UserAssetConfig", id.toString(), this);
    }
  }

  static load(id: string): UserAssetConfig | null {
    return changetype<UserAssetConfig | null>(store.get("UserAssetConfig", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    return value!.toString();
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get dripsEntryIds(): Array<string> {
    let value = this.get("dripsEntryIds");
    return value!.toStringArray();
  }

  set dripsEntryIds(value: Array<string>) {
    this.set("dripsEntryIds", Value.fromStringArray(value));
  }

  get dripsEntries(): Array<string> {
    let value = this.get("dripsEntries");
    return value!.toStringArray();
  }

  set dripsEntries(value: Array<string>) {
    this.set("dripsEntries", Value.fromStringArray(value));
  }

  get balance(): BigInt {
    let value = this.get("balance");
    return value!.toBigInt();
  }

  set balance(value: BigInt) {
    this.set("balance", Value.fromBigInt(value));
  }

  get assetConfigHash(): Bytes {
    let value = this.get("assetConfigHash");
    return value!.toBytes();
  }

  set assetConfigHash(value: Bytes) {
    this.set("assetConfigHash", Value.fromBytes(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}

export class DripsSetEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("userId", Value.fromBigInt(BigInt.zero()));
    this.set("assetId", Value.fromBigInt(BigInt.zero()));
    this.set("receiversHash", Value.fromBytes(Bytes.empty()));
    this.set("balance", Value.fromBigInt(BigInt.zero()));
    this.set("blockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DripsSetEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DripsSetEvent entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DripsSetEvent", id.toString(), this);
    }
  }

  static load(id: string): DripsSetEvent | null {
    return changetype<DripsSetEvent | null>(store.get("DripsSetEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get receiversHash(): Bytes {
    let value = this.get("receiversHash");
    return value!.toBytes();
  }

  set receiversHash(value: Bytes) {
    this.set("receiversHash", Value.fromBytes(value));
  }

  get balance(): BigInt {
    let value = this.get("balance");
    return value!.toBigInt();
  }

  set balance(value: BigInt) {
    this.set("balance", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class HashToDripsSetDetail extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("userId", Value.fromBigInt(BigInt.zero()));
    this.set("assetId", Value.fromBigInt(BigInt.zero()));
    this.set("currentDripSetEvent", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save HashToDripsSetDetail entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save HashToDripsSetDetail entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("HashToDripsSetDetail", id.toString(), this);
    }
  }

  static load(id: string): HashToDripsSetDetail | null {
    return changetype<HashToDripsSetDetail | null>(
      store.get("HashToDripsSetDetail", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get currentDripSetEvent(): string {
    let value = this.get("currentDripSetEvent");
    return value!.toString();
  }

  set currentDripSetEvent(value: string) {
    this.set("currentDripSetEvent", Value.fromString(value));
  }
}

export class DripsEntry extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromString(""));
    this.set("senderAssetConfig", Value.fromString(""));
    this.set("receiverUserId", Value.fromBigInt(BigInt.zero()));
    this.set("config", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DripsEntry entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DripsEntry entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DripsEntry", id.toString(), this);
    }
  }

  static load(id: string): DripsEntry | null {
    return changetype<DripsEntry | null>(store.get("DripsEntry", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): string {
    let value = this.get("sender");
    return value!.toString();
  }

  set sender(value: string) {
    this.set("sender", Value.fromString(value));
  }

  get senderAssetConfig(): string {
    let value = this.get("senderAssetConfig");
    return value!.toString();
  }

  set senderAssetConfig(value: string) {
    this.set("senderAssetConfig", Value.fromString(value));
  }

  get receiverUserId(): BigInt {
    let value = this.get("receiverUserId");
    return value!.toBigInt();
  }

  set receiverUserId(value: BigInt) {
    this.set("receiverUserId", Value.fromBigInt(value));
  }

  get config(): BigInt {
    let value = this.get("config");
    return value!.toBigInt();
  }

  set config(value: BigInt) {
    this.set("config", Value.fromBigInt(value));
  }
}

export class DripsReceiverSeenEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("receiversHash", Value.fromBytes(Bytes.empty()));
    this.set("userId", Value.fromBigInt(BigInt.zero()));
    this.set("config", Value.fromBigInt(BigInt.zero()));
    this.set("blockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DripsReceiverSeenEvent entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DripsReceiverSeenEvent entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DripsReceiverSeenEvent", id.toString(), this);
    }
  }

  static load(id: string): DripsReceiverSeenEvent | null {
    return changetype<DripsReceiverSeenEvent | null>(
      store.get("DripsReceiverSeenEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get receiversHash(): Bytes {
    let value = this.get("receiversHash");
    return value!.toBytes();
  }

  set receiversHash(value: Bytes) {
    this.set("receiversHash", Value.fromBytes(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get config(): BigInt {
    let value = this.get("config");
    return value!.toBigInt();
  }

  set config(value: BigInt) {
    this.set("config", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Give extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromBytes(Bytes.empty()));
    this.set("isAccountGive", Value.fromBoolean(false));
    this.set("account", Value.fromBigInt(BigInt.zero()));
    this.set("receiver", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigInt(BigInt.zero()));
    this.set("blockTimestampGiven", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Give entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Give entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Give", id.toString(), this);
    }
  }

  static load(id: string): Give | null {
    return changetype<Give | null>(store.get("Give", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get isAccountGive(): boolean {
    let value = this.get("isAccountGive");
    return value!.toBoolean();
  }

  set isAccountGive(value: boolean) {
    this.set("isAccountGive", Value.fromBoolean(value));
  }

  get account(): BigInt {
    let value = this.get("account");
    return value!.toBigInt();
  }

  set account(value: BigInt) {
    this.set("account", Value.fromBigInt(value));
  }

  get receiver(): Bytes {
    let value = this.get("receiver");
    return value!.toBytes();
  }

  set receiver(value: Bytes) {
    this.set("receiver", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get blockTimestampGiven(): BigInt {
    let value = this.get("blockTimestampGiven");
    return value!.toBigInt();
  }

  set blockTimestampGiven(value: BigInt) {
    this.set("blockTimestampGiven", Value.fromBigInt(value));
  }
}

export class IdentityMetaData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("key", Value.fromBytes(Bytes.empty()));
    this.set("multiHash", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IdentityMetaData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IdentityMetaData entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IdentityMetaData", id.toString(), this);
    }
  }

  static load(id: string): IdentityMetaData | null {
    return changetype<IdentityMetaData | null>(
      store.get("IdentityMetaData", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get key(): Bytes {
    let value = this.get("key");
    return value!.toBytes();
  }

  set key(value: Bytes) {
    this.set("key", Value.fromBytes(value));
  }

  get multiHash(): Bytes {
    let value = this.get("multiHash");
    return value!.toBytes();
  }

  set multiHash(value: Bytes) {
    this.set("multiHash", Value.fromBytes(value));
  }
}
